import pandas as pd

def read_QE_band(file_name):
    '''
    Converts the .gnu file output from Quantum Espresso and 
    transforms it into a DataFrame where each column represents a band.

    Args:
        file_name: string containing the path to the .gnu file generated by QE
    Returns:
        Pandas DataFrame with bands in separate columns (e0, e1, e2...)
    '''
    data = []
    with open(file_name, 'r') as input_file:
        for line in input_file:
            parts = line.strip().split()
            if len(parts) == 2:
                k, E = parts
                data.append([float(k), float(E)])

    columns = ['k', 'E']
    banda = pd.DataFrame(data, columns=columns)    
    indices = list(set(banda['k']))
    indices.sort()
    bandas = {}
    bandas['k'] = indices
    ncol = list(banda['k']).count(indices[0])
    for i in range(ncol):
        bandas['e'+str(i)] = []
    for i in indices:
        pos = [index for index, value in enumerate(banda['k']) if value == i]
        lista_energias = [banda['E'][p] for p in pos]
        for n in range(ncol):
            bandas['e'+str(n)].append(lista_energias[n])
    bandas = pd.DataFrame(bandas)
    return pd.DataFrame(bandas)


##############################################################################
# Functions to read Crystal output after cutting slabs for surface analysis. #
##############################################################################

def read_crystal_file(file_path):
    """ 
    Reads the out file and outpus a dataframe of atomic position
    """
    with open(file_path, 'r') as file:
        lines = file.readlines()
    start_index = lines.index(' CARTESIAN COORDINATES - PRIMITIVE CELL\n') + 4
    for i in range(start_index, len(lines)):
        if lines[i].split()[0].isdigit():
            last_line = i
    data_df = {'atom_number': [],
        'atom_species': [],
        'X(ANGSTROM)': [],
        'Y(ANGSTROM)': [],
        'Z(ANGSTROM)': []}
    data_df = pd.DataFrame(data_df)
    for line in lines[start_index : last_line+1]:
        line_list = []
        for k in range(len(line.split())):
            if k != 2:
                line_list.append(float(line.split()[k]))
            if k == 2:
                line_list.append(line.split()[k])
        line_list = line_list[1:]
        data_df.loc[len(data_df)] = line_list
    return data_df

def read_crystal_file_lat(file_path):
    """
    Reads the out file and outpus list of new lattice vectors of the slab
    """
    with open(file_path, 'r') as file:
        lines = file.readlines()
    start_index = lines.index('     THE SELECTED PLANE IS IN THE X-Y PLANE\n') + 4  
    B1 = lines[start_index].split()[1:]
    B2 = lines[start_index+1].split()[1:]
    B3 = lines[start_index+2].split()[1:]
    return [B1,B2,B3]


def sort_atoms(df_atoms):
    """Sort the atoms by atomic numbers
    
    Output:
        A sorted dataframe
    """
    
    df_sorted = df_atoms.sort_values('atom_number', ascending=False).reset_index(drop=True)
    
    return df_sorted

def zero_xyz(df_atoms):
    """Add the min value to Z
    
    Output:
        A normalized dataframe
    """
    
    df_atoms['Z(ANGSTROM)'] = df_atoms['Z(ANGSTROM)'] - df_atoms['Z(ANGSTROM)'].min()
    
    return df_atoms


def print_POSCAR(df_atoms, lat, FROZEN_LAYERS):
    """
    Takes a dataframe of atomic positions and a list of lattice vectors and
    prints it in the format of VASP POSCAR input file.
    """
    # ADD VACUUM:
    lat[2][2] = str(float(lat[2][2]) + max(df_atoms['Z(ANGSTROM)']) + 15)
    for k in lat:
        print('   '+ '    '.join([format(float(b), '.15f')[:15] for b in k]))
    species = sorted(set(df_atoms['atom_species']), key=list(df_atoms['atom_species']).index)
    print(' '.join(species))
    quant = []
    for s in species:
        quant.append(list(df_atoms['atom_species']).count(s))
    for i in range(len(quant)):
        quant[i] = str(quant[i])
    print(' '.join(quant))
    
    if bool(FROZEN_LAYERS):
        print('Selective dynamics')
    print('direct')

    for i in range(len(df_atoms['Z(ANGSTROM)'])):
        pos = [df_atoms['X(ANGSTROM)'][i],df_atoms['Y(ANGSTROM)'][i],df_atoms['Z(ANGSTROM)'][i]]
        for j in range(len(pos)):
            pos[j] = format(pos[j], '.15f')
            pos[j] = pos[j][:15]
        froz = str(bool(df_atoms['FX'][i]))[0] + str(bool(df_atoms['FY'][i]))[0] + str(bool(df_atoms['FZ'][i]))[0]
        if bool(FROZEN_LAYERS):
            line = '   ' + '   '.join(map(str, pos)) + ' ' + '   ' + froz[0] + '   ' + froz[1] + '   ' + froz[2]
        else:
            line = '   ' + '   '.join(map(str, pos)) + ' ' + df_atoms['atom_species'][i]
        print(line)


def print_QE(df_atoms, lat, FROZEN_LAYERS):
    """
    Takes a dataframe of atomic positions and a list of lattice vectors and
    prints it in the format of Quantum Espresso input file.
    """
    # ADD VACUUM:
    lat[2][2] = str(float(lat[2][2]) + max(df_atoms['Z(ANGSTROM)']) + 15)
    print("CELL_PARAMETERS (alat=  1.889725989)")
    for k in lat:
        print('   '+ '   '.join([format(float(b), '.15f')[:15] for b in k]))
    print('ATOMIC_POSITIONS (crystal)')

    for i in range(len(df_atoms['Z(ANGSTROM)'])):
        pos = [df_atoms['X(ANGSTROM)'][i],df_atoms['Y(ANGSTROM)'][i],df_atoms['Z(ANGSTROM)'][i]]
        for j in range(len(pos)):
            pos[j] = format(pos[j], '.15f')
            pos[j] = pos[j][:15]
        froz = str(df_atoms['FX'][i]) + str(df_atoms['FY'][i]) + str(df_atoms['FZ'][i])
        if bool(FROZEN_LAYERS):
            line = df_atoms['atom_species'][i]+'   ' + '   '.join(map(str, pos)) + '   ' + froz[0] + '   ' + froz[1] + '   ' + froz[2]
        else:
            line = df_atoms['atom_species'][i]+'   ' + '   '.join(map(str, pos))
        print(line)
        
def add_frozen(df_atoms, FROZEN_LAYERS):
    """
    Add a frozen command for specific atoms depending on FROZEN_LAYERS list
    """
    num_atoms = len(df_atoms)
    if bool(FROZEN_LAYERS):
        num_layers = len(FROZEN_LAYERS)
        num_atoms_layer = num_atoms/num_layers
        if round(num_atoms_layer%1, 5) != 0:
            print('Incoherent frozen layers')
            return
        frozen_list = []
        for i in FROZEN_LAYERS:
            frozen_list = frozen_list + [int(i)]*int(num_atoms_layer)
        
    else:
        frozen_list = [1] * num_atoms
    
    df_atoms['FX'], df_atoms['FY'], df_atoms['FZ'] = frozen_list, frozen_list, frozen_list
    
    return df_atoms        
        
        
def convert_crystal_data(file_name, QE = False, FROZEN_LAYERS = False):
    """
    Takes the file name, converts to sorted and translated dataframe, and
    prints it in either VASP or QE format.
    """
    df_atoms = read_crystal_file(file_name)
    df_atoms = add_frozen(df_atoms, FROZEN_LAYERS)
    df_atoms = sort_atoms(df_atoms)
    df_atoms = zero_xyz(df_atoms)
    lat = read_crystal_file_lat(file_name)
    if QE == False:
        print_POSCAR(df_atoms,lat, FROZEN_LAYERS)
    else:
        print_QE(df_atoms,lat, FROZEN_LAYERS)
    return df_atoms

#########################################################
# Functions to read relax output and create scf inputs. #
#########################################################

def read_relax(file_path_rr):
    """ 
    Reads the relax.out file and outpus a string of cell parameters and atomic position
    """
    file_name = 'relax.out'
    file_path_rr = file_path_rr + file_name
    with open(file_path_rr, 'r') as file:
        lines = file.readlines()
    start_index = lines.index('Begin final coordinates\n') + 2
    final_index = lines.index('End final coordinates\n')
    atomic_positions = ''.join(lines[start_index:final_index])
    n_atoms = final_index - start_index - 1
    return n_atoms, atomic_positions

def read_cell_parameters(file_path_rcp):
    """ 
    Reads the relax.out file and outpus a string of cell parameters and atomic position
    """
    file_name = 'relax.in'
    file_path_rcp = file_path_rcp + file_name
    with open(file_path_rcp, 'r') as file:
        lines = file.readlines()
    start_index = lines.index('''CELL_PARAMETERS 'angstrom'\n''')
    cell_parameters = ''.join(lines[start_index:start_index+4])
    return cell_parameters
    


def save_scf(file_path_ss, n_atoms, atomic_positions, cell_parameters):
    content = """&CONTROL
    calculation   = 'scf',
    verbosity='high',
    restart_mode  = 'from_scratch',
    nstep         =  200
    pseudo_dir = './'
    prefix='out',
    tstress = .true.,
    tprnfor = .true.,
 /
&SYSTEM
    ibrav = 0,
    nat= {"""
    content2 = """},
    ntyp= 3,
    ecutwfc     = 30.0 ,
    ecutrho     = 300.0 ,
    nspin = 1 ,
    degauss = 0.01 ,
    occupations='smearing',
 /
&ELECTRONS
    electron_maxstep  = 500
    conv_thr          = 1.0e-6
    mixing_mode       = 'plain'
    mixing_beta       = 0.3
    diagonalization   = 'david'
 /
&IONS
    ion_dynamics      = 'bfgs'
    ion_positions     = 'default '
 /
 &cell
    cell_dynamics='bfgs',
    press=0.0,
    press_conv_thr=0.5,
/
ATOMIC_SPECIES
 Cs     132.905 Cs.upf
 Pb     207.200 Pb.upf
 Br     79.904  Br.upf
K_POINTS {automatic}
4 4 1 0 0 0
"""
    scf_text = content + str(n_atoms) + content2 + cell_parameters + atomic_positions

    file_path_ss = file_path_ss + "scf.in"

    with open(file_path_ss, "w") as file:
        file.write(scf_text)

    print(f'The content has been saved to {file_path_ss}.')
    
    
############################################
# Functions to calculate surface energies. #
############################################

def single_surface(E_bulk, E_slab, n_bulk, n_slab, A):
    """Calculate the surface energy of facets by the single surface method
    
    Inputs:
        E_bulk: Bulk total energy (Ry)
        E_slab: Slab total energy (Ry)
        n_bulk: Number of atoms in bulk
        n_slab: Number of atoms in slab
        A: Slab area (Å²)
    Output:
        E_s: surface energy of the facet (J/m²)
    """

    # Energy calculations
    n = n_slab/n_bulk # proportion of bulks repetitions in the slab
    E_s_wda = (E_slab - n*E_bulk)/(2*A) # Surface energy (Ry/A²)
    
    # Dimensional analysis
    E_s = E_s_wda*217.98732373451776 # Surface energy (J/m²)
    return E_s

def cleavage_energy(E_bulk, E_frozen, E_A_relax, E_B_relax, n_slab, n_bulk, A):
    """Calculate the surface energy of facets by the cleavage energy method
    
    Inputs:
        E_bulk: Bulk total energy (Ry)
        E_frozen: Slab with all atoms frozed total energy (Ry)
        E_A_relax: Slab with B-atoms atoms frozed total energy (Ry)
        E_B_relax: Slab with A-atoms atoms frozed total energy (Ry)
        n_bulk: Number of atoms in bulk
        n_slab: Number of atoms in slabs (same for the 3 slabs)
        A: Slabs area (same for the 3 slabs) (Å²)
    Output:
        E_A: surface energy of the facet in termination A (J/m²)
        E_B: surface energy of the facet in termination B (J/m²)
    """
    # Dimensional analysis
    E_bulk_J = E_bulk*2.179874099e-18 # Bulk total energy (J)
    E_frozen_J = E_frozen*2.179874099e-18 # Slab total energy (J)
    E_A_relax_J = E_A_relax*2.179874099e-18 # Slab total energy (J)
    E_B_relax_J = E_B_relax*2.179874099e-18 # Slab total energy (J)
    A_m_2 = A*1e-20 # Slab area (m²)
    
    # Energy calculations
    n = n_slab/n_bulk
    E_relax_A = (E_frozen_J - n*E_bulk_J)/A_m_2 - (E_A_relax_J - n*E_bulk_J)/A_m_2 # Relaxation energy A (J/m²)
    E_relax_B = (E_frozen_J - n*E_bulk_J)/A_m_2 - (E_B_relax_J - n*E_bulk_J)/A_m_2 # Relaxation energy B (J/m²)
    E_cleave = (E_frozen_J - n*E_bulk_J)/(2*A_m_2) # Cleavage energy (J/m²) 
    E_A = E_cleave - E_relax_A # Surface energy A (J/m²)
    E_B = E_cleave - E_relax_B # Surface energy B (J/m²)
    return E_A, E_B